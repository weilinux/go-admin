//参考 Spup的功能
//参考 Spup的功能
//参考 Spup的功能


批量执行
主机命令在线批量执行

在线终端
轻量级跳板机，浏览器在线终端管理

文件管理
主机文件在线上传下载

任务计划
灵活的在线任务计划

发布部署
多种发布模式，轻松搞定CICD

配置中心
抹平不同环境的代码差异

监控中心
支持网站、端口、进程、自定义监控

报警中心
支持微信、邮件、钉钉、飞书等报警方式



//参考一下这个 https://github.com/ren-zc/opsHeart_server
一个全新的运维管理平台
具备以下特性：
主机批量管理
远程执行（命令、脚本）
任务调度，支持以下功能
串行任务
并行任务
任务组
任务组嵌套
任务依赖
布尔条件任务
灰度执行（各个维度的灰度）
暂停后确认

定时任务
agent启动任务
agent数据采集

用户管理
权限管理
cmd执行权限管理
操作审计

外部系统调用管理
权限管理
调用审计

交互式前端cmd
agent组管理






function parse_sql_file() {
    local sql_file="$1"
    local current_sql=""

    [[ ! -f "$sql_file" ]] && { echo "Error: SQL file not found!"; return 1;}

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        line=$(echo "$line" | sed 's/\r//g')
        current_sql+="$line "

        if [[ "$line" =~ \;$ ]]; then
            current_sql=${current_sql%;}
            local first_word=$(echo "$current_sql" | awk '{print toupper($1)}')
            local  first_two_word=$(echo "$current_sql" | awk '{print toupper($1), toupper($2)}')

            if check_sql_type "$first_word" || check_sql_type "$first_two_word"; then
                echo " sql query ready to run: ${current_sql}"
                echo "${current_sql}" >> "$VALIDATED_SQL_FILE"
            else
                echo " sql query restrict to run: ${current_sql}"
            fi
            current_sql=""
        fi
    done < "$sql_file"
}

function check_sql_type {
    local sql="$1"
    case $sql in
        SELECT|DESC|SHOW|EXPLAIN|"SHOW CREATE"|"SHOW INDEX"|"SHOW PROCESSLIST")
            return 0
            ;;
        CREATE|UPDATE|DELETE|ALTER|INSERT|TRUNCATE|DROP|GRANT|REVOKE|SET|REPLACE| \
        "CREATE TABLE"|"DELETE TABLE" |"DROP TABLE"|"ALTER TABLE"|"OPTIMIZE TABLE"|"INSERT INTO"|"RENAME TABLE"|"TRUNCATE TABLE"| \
        "CREATE VIEW"|"DROP VIEW"|"CREATE PROCEDURE"|"DROP PROCEDURE"| \
        "CREATE USER"|"DROP USER"|"GRANT"|"REVOKE"| \
        "START TRANSACTION"|"COMMIT"|"ROLLBACK"| \
        "CREATE TRIGGER"|"DROP TRIGGER"| \
        "REPLACE INTO")
            return 1
            ;;
        *)
            return 1
            ;;
    esac
}




function format_query_output() {
    local query_output_file=$1
    [[ ! -f "$query_output_file" ]] && { echo "Error: File '$query_output_file' does not exist."; return 1; }

    declare -a max_lengths=()
    while IFS=$'\t' read -r -a line; do
        for i in "${!line[@]}"; do
            length=${#line[i]}
            [[ $length -gt ${max_lengths[i]:-0} ]] && max_lengths[i]=$length
        done
    done < "$query_output_file"

    local aligned_output=$(mktemp /tmp/aligned_output.XXXXXX.txt)
    local aligned_output_wrap=$(mktemp /tmp/aligned_output_wrap.XXXXXX.txt)

    if [ "$2" == "csv" ]; then
        max_lengths_string="${max_lengths[*]}"
        awk -v max_lengths="$max_lengths_string"  -F'\t' -v OFS=',' '
        BEGIN {
            split(max_lengths, lengths_array, " ");
        }
        {
            for (i = 1; i <= NF; i++){
                if (length($i) > lengths_array[i]) {
                     lengths_array[i] = length($i)
                }
                    printf "%-*s", lengths_array[i], $i;
                if (i <= NF) { printf OFS; }
            }
            print "";
        }' "$query_output_file" > "/tmp/tmp.csv"
    fi

    max_lengths_string="${max_lengths[*]}"
    awk -v max_lengths="$max_lengths_string"  -F'\t' -v OFS='|' '
    BEGIN {
        split(max_lengths, lengths_array, " ");
    }
    {
        for (i = 1; i <= NF; i++){
            gsub(/\|/, "\\t");
            if (length($i) > lengths_array[i]) {
                 lengths_array[i] = length($i)
            }
            printf "%-*s", lengths_array[i], $i
            if (i <= NF) { printf OFS; }
        }
        print "";
    }' "$query_output_file" > "$aligned_output"

    # Prepare columns for formatting with column command
    local table_columns=""
    local table_columns_wrap=""
    local row_width=0
    local table_long_column_fixed=70
    for i in "${!max_lengths[@]}"; do
        col_name="C$((i + 1))"
        table_columns+="$col_name,"

        local column_width=max_lengths[i]
        if [[ ${max_lengths[i]} -gt ${table_long_column_fixed} ]]; then
            table_columns_wrap+="$col_name,"
            column_width=$table_long_column_fixed
        fi
        row_width=$(( row_width + column_width + 2 ))
    done

    table_columns=${table_columns%,}
    table_columns_wrap=${table_columns_wrap%,}

    column --separator '|' -o ' | '  --output-width $row_width  --table --table-noheadings \
           --table-columns "$table_columns"  --table-wrap "$table_columns_wrap" < "$aligned_output" > "$aligned_output_wrap"

    awk -F '\|' -v OFS='|' '{
        for (i = 1; i <= NF; i++) {
            original_length = length($i);
            count = gsub(/\\t/, "|", $i);
            new_length = length($i);
            num_spaces = original_length - new_length;
            printf "%s%*s", $i, num_spaces, "";  # Print the field and append spaces
            if (i < NF) { printf OFS; }
        }
        print "";
    }' "$aligned_output_wrap" >  "$FORMATTED_DBLOGOUTPUT"

    rm "$aligned_output"
    rm "$aligned_output_wrap"
}

function encrypt_and_zip() {
    local file=$?
    [[ ! -f "$file" ]] && { echo "Error: File not found for encryption!"; return 1;}
    local encrypted_file=$(mktemp /tmp/encrypted.XXXXXX)
    # where to store pwd
    openssl enc -aes-256-cbc -salt -in "$file" -out "$encrypted_file" -k "$(openssl rand -base64 32)"
    zip -r "$file.zip" "$encrypted_file"
    rm "$encrypted_file"
}

function send_notifiy_email() {
    local email_addresses="weilinux@163.com"
    [[ ! -s $FORMATTED_DBLOGOUTPUT ]] && { echo "No output to send."; return 0; }

    local sendmail_template="/tmp/sendemail-$(date '+%y%m%d%H%M%S').eml"
    {
      echo "From: $(whoami)@$(hostname)"
      echo "To: ${email_addresses}"
      echo "Subject: SQL Execution Summary (${ENVIRONMENT})"
      echo "Content-Type: text/html"
      echo "MIME-Version: 1.0"
      echo ""
      echo "<pre>"
      cat "${FORMATTED_DBLOGOUTPUT}"
      echo "</pre>"
    } > "${sendmail_template}"

    echo "Sending notification mail to address(es): ${email_addresses}"
    sendmail "${email_addresses}" < ${sendmail_template} && echo "Mail sent" || echo "Mail couldn't be sent"
    rm -f ${sendmail_template}
}








